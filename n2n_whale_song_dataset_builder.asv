% Noise2Noise Dataset Builder
% Searches the detection results and retrieves the time-datestamps for the
% best detections, by calculating a combined score from SNR and SINR.
%
% Ben Jancovich, 2024
% Modified by Claude, 2024
% Centre for Marine Science and Innovation
% School of Biological, Earth and Environmental Sciences
% University of New South Wales, Sydney, Australia
%
clear
close all
clc

%% Set parameters
quantileThreshSINR = 0.3;
minutesSeparation = 10;
soiHiFreq = 60;
fadeLen = 0.5;
nTrainingPairs = 10000;
numHashFunctions = 500;
numBands = 50;

%% Set up paths and load configuration
here = pwd;
gitRoot = here(1:regexp(here, 'Git', 'end'));
localisationPath = fullfile(gitRoot, "localisation_and_source_level_est");
run(fullfile(localisationPath, 'config.m'));

%% Set input data paths
rawAudioPath = "D:\Diego Garcia South";
detectionsPath = "C:\Users\z5439673\OneDrive - UNSW\H0419778\Manue_Chagos_RawData\DGS";
wav_subdir_prefix = 'DiegoGarcia';
cleanAudioSavePath = 'C:\Users\z5439673\Git\localisation_and_source_level_est\2_DATA';

%% Set output datapath
n2n_dataset_root = 'C:\Users\z5439673\OneDrive - UNSW\H0419778\Noise2Noise_Audio';
n2n_dataset_inputs = fullfile(n2n_dataset_root, 'Inputs');
n2n_dataset_targets = fullfile(n2n_dataset_root, 'Targets'); 

%% Date and time formats
wav_dateformat_serial = 'yymmdd-HHMMSS';
wav_dateformat_datetime = 'yyMMdd-HHmmss';

%% Load and process detections
detectionsFiles = dir(fullfile(detectionsPath, '*.mat'));
% detectionsAll = table();

% Calculate expected number of samples
expected_num_samples = (call_duration + (buffer_duration*2)) * Fs + 1;

% Preallocate cell array for faster concatenation
tempTables = cell(length(detectionsFiles), 1);

for i = 1:length(detectionsFiles)
    data = load(fullfile(detectionsPath, detectionsFiles(i).name), 'detections');
    tempTables{i} = array2table(data.detections, 'VariableNames', ...
        {'Year', 'JulianDay', 'Month', 'Week', 'Time', 'SNR', 'SINR', 'SNRClass'});
end

% Concatenate all tables at once
detectionsAll = vertcat(tempTables{:});

% Remove invalid detections
validDetection = ~(isnan(detectionsAll.SNR) | isnan(detectionsAll.SINR) | ...
    isinf(detectionsAll.SNR) | isinf(detectionsAll.SINR));
detectionsAll = detectionsAll(validDetection, :);

% Normalize SINR and apply threshold
detectionsAll.SINR_normalized = detectionsAll.SINR ./ max(abs(detectionsAll.SINR));
SINR_thresh = quantile(detectionsAll.SINR_normalized, quantileThreshSINR);
detectionsAll = detectionsAll(detectionsAll.SINR_normalized >= SINR_thresh, :);

% Convert serial time to datetime and sort
detectionsAll.datetime_Readable = datetime(detectionsAll.Time, 'ConvertFrom', 'datenum');
[~, sortIdx] = sort(detectionsAll.Time);
detectionsAll = detectionsAll(sortIdx, :);

% Filter based on time separation
minTimeDiff = minutesSeparation / (24 * 60);
validDetections = false(height(detectionsAll), 1);
validDetections(1) = true;
lastValidTime = detectionsAll.Time(1);

for i = 2:height(detectionsAll)
    if detectionsAll.Time(i) - lastValidTime >= minTimeDiff
        validDetections(i) = true;
        lastValidTime = detectionsAll.Time(i);
    end
end

detectionsAll = detectionsAll(validDetections, :);

%% Process audio segments
Fs = 0; % Initialize Fs
detectionAudio = cell(height(detectionsAll), 1);

% Pre-compute common values
for i = 1:height(detectionsAll)
    wav_subdir_paths(i) = fullfile(rawAudioPath, strcat(wav_subdir_prefix, num2str(detectionsAll{i, 'Year'})), 'wav/');
    detection_datestrings{i} = datestr(detectionsAll{i, 'Time'}, wav_dateformat_serial);
end

parfor i = 36262:height(detectionsAll)
    wavs_filelist = dir(fullfile(wav_subdir_paths(i), '*.wav'));
    wav_filename = find_closest_wav(wavs_filelist, detection_datestrings{i});
    wav_path = fullfile(wav_subdir_paths(i), wav_filename);
    
    try
        [audiodata, Fs] = audioread(wav_path);
    catch
        warning('Failed to read audio file for detection %d. Returning "NaN".', i);
        detectionAudio{i} = NaN;
        continue;  % Skip to the next iteration
    end

    file_start_str = wav_filename(7:end-4);
    file_start_datetime = datetime(file_start_str, 'InputFormat', wav_dateformat_datetime);
    wav_duration = numel(audiodata) / Fs;
    file_end_datetime = file_start_datetime + seconds(wav_duration);
    
    file_start_serial = datenum(file_start_datetime);
    file_end_serial = datenum(file_end_datetime);
    
    timevector_serial = linspace(file_start_serial, file_end_serial, numel(audiodata));
    detection_datetime_serial = datenum(detection_datestrings{i}, wav_dateformat_serial);
    
    [~, dettime_idx] = min(abs(timevector_serial - detection_datetime_serial));
    
    ROIstart = max(1, dettime_idx - round(buffer_duration * Fs));
    ROIend = min(length(audiodata), dettime_idx + round((call_duration + buffer_duration) * Fs));
    
    % Handle case where detection audio is split across two files
    if ROIstart >= 1 && ROIend <= length(audiodata)
        detectionAudio{i} = audiodata(ROIstart:ROIend);
    else
        warning('Audio data crosses boundary of two consecutive .wav files. Returning "NaN" for detection %d', i);
        detectionAudio{i} = NaN;
    end

    % Handle weird cases where the detection audio returned is too short
    if  numel(detectionAudio{i}) < expected_num_samples
        warning('Audio data returned has too few samples. Returning "NaN" for detection %d', i);
        detectionAudio{i} = NaN;
    end
    disp(i)
end

% Hacky - put Fs back in as a global - it's always 250 for our data anyway.
Fs = 250;

% Put detection audio in detections table as a new variable
detectionsAll = addvars(detectionsAll, detectionAudio);

% Remove empty/NaN cells (skipped detections)
detectionsAll = detectionsAll(~cellfun(@(x) isempty(x) || ...
    any(isnan(x)), detectionsAll.detectionAudio), :);

%% Save Checkpoint
nDetections = height(detectionsAll);
now = char(datetime('now', 'Format', 'yyyy-MM-dd_HH-mm-SS'));
saveName = fullfile(n2n_dataset_root, [now, '_all_valid_detections_n=', num2str(nDetections), '.mat']);
save(saveName, 'detectionsAll', '-v7.3');

%% Clear and Re-Load Checkpoint

% Clear variables except those needed
clearvars -except soiHiFreq fadeLen nTrainingPairs numHashFunctions numBands Fs 
n2n_dataset_root = 'C:\Users\z5439673\OneDrive - UNSW\H0419778\Noise2Noise_Audio';

% Find files matching the pattern
savePattern = fullfile(n2n_dataset_root, '*_all_valid_detections_n=*.mat');
files = dir(savePattern);

if isempty(files)
    error('No matching files found.');
elseif isscalar(files)
    selectedFile = files(1);
else
    % Multiple files found, display them and ask user to select
    fprintf('Multiple matching files found:\n');
    for i = 1:length(files)
        fprintf('%d: %s\n', i, files(i).name);
    end
    
    % Ask user to select a file
    while true
        selection = input('Enter the number of the file you want to load: ');
        if isnumeric(selection) && selection > 0 && selection <= length(files)
            selectedFile = files(selection);
            break;
        else
            fprintf('Invalid selection. Please enter a number between 1 and %d.\n', length(files));
        end
    end
end

% Construct the full path to the selected file
% Use only selectedFile.name here, as selectedFile.folder already contains the full path
saveName = fullfile(selectedFile.folder, selectedFile.name);

% Clear variables except those needed
clearvars -except saveName soiHiFreq fadeLen nTrainingPairs numHashFunctions numBands Fs

% Load the file
load(saveName)
fprintf('Loaded file: %s\n', saveName);

%% Preprocess audio
% Reload Fs and other vars:
% run(fullfile(localisationPath, 'config.m'));

[nSamps, ~] = size(detectionsAll{1, 'detectionAudio'}{1,1});  % Assume all audio segments have the same length
nSignals = height(detectionsAll);

windowSamps = 2 * fadeLen * Fs;
if mod(windowSamps, 2) == 0
    windowSamps = windowSamps + 1;
end

window = hann(windowSamps);
onesToAdd = nSamps - windowSamps;
windowFull = [window(1:floor(windowSamps/2+1)); ones(onesToAdd-1, 1); flipud(window(1:floor(windowSamps/2+1)))];

Wn = soiHiFreq / (Fs / 2);
[b, a] = butter(8, Wn, 'high');

preprocessedAudio = cell(nSignals, 1);

for i = 1:nSignals
    audio = detectionsAll{i, 'detectionAudio'}{1};
    audio = audio ./ max(abs(audio));
    audio = audio .* windowFull;
    audio = audio - mean(audio);
    
    if any(isinf(audio)) || all(audio == 0) || any(isnan(audio))
        preprocessedAudio{i} = NaN(size(audio));
    else
        preprocessedAudio{i} = filtfilt(b, a, audio);
    end
end

% Put detection audio in detections table as a new variable
detectionsAll = addvars(detectionsAll, preprocessedAudio);

% Remove empty/NaN cells (Failed preprocessing)
detectionsAll = detectionsAll(~cellfun(@(x) isempty(x) || ...
    any(isnan(x)), detectionsAll.preprocessedAudio), :);

clear

%% Generate Uncorrelated Signal Pairs

% Use Local Similarity Hashing in the Wavelet Domain to group dissimilar
% signals:
[signalPairs, signalPairIndices] = waveletLSH(...
    cell2mat(detectionsAll.preprocessedAudio'), nTrainingPairs, ...
    numHashFunctions, numBands);

nPairs = length(signalPairs);
similarity = zeros(nPairs, 1);
rawMetrics = zeros(nPairs, 4);
for i = 1:nPairs
    % Get measure of similarity for each pair
    [similarity(i), rawMetrics(i,:)] = signalSimilarity(signalPairs{i, 1}, signalPairs{i, 2}, Fs);
end

% Sort simmilarity from least to most similar
[~, sortedSimilarityIndices] = sort(similarity, "ascend");

% Save out signals
for i = 1:nTrainingPairs
    % Retrieve this pair's audio data
    target = detectionsAll(signalPairIndices(sortedSimilarityIndices(i), 1), 'detectionAudio').detectionAudio{1};
    input = detectionsAll(signalPairIndices(sortedSimilarityIndices(i), 2),  'detectionAudio').detectionAudio{1};
    % Define this pair's file paths and names
    filename_target = fullfile(n2n_dataset_root, train_targets, ['train_target_', num2str(i), '.wav']);
    filename_input = fullfile(n2n_dataset_root, train_inputs, ['train_input_', num2str(i), '.wav']);
    % Save out wav files
    audiowrite(filename_target, target, Fs);
    audiowrite(filename_input, input, Fs);
end
